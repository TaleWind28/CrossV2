\documentclass{article}

\usepackage[italian]{babel}
\usepackage[a4paper, margin=2cm]{geometry}
\usepackage{xcolor}
\usepackage{tocloft}
\usepackage{titlesec}
\definecolor{bluscuro}{RGB}{0, 0, 139}  % Definizione di un blu scuro
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=bluscuro]{hyperref}
\usepackage{wrapfig}

\graphicspath{{immagini/}}

% Cambiare il colore delle sezioni
\titleformat{\section}
  {\color{bluscuro}\Large\bfseries} % Stile: colore + grande + grassetto
  {\thesection}{1em}{}

\titleformat{\subsection}
  {\color{bluscuro}\large\bfseries} % Stile: colore + medio + grassetto
  {\thesubsection}{1em}{}

\renewcommand{\cfttoctitlefont}{\color{bluscuro}\huge\bfseries} % Titolo "Indice" in blu e grande

\title{Documentazione Cross}
\author{Martini Matteo 636694}

\begin{document}
\maketitle

\tableofcontents

\section{Scelte Progettuali}
Il progetto è stato realizzato seguendo i principi SOLID per garantire modularità, scalabilità e manutenibilità 
\subsection{Organizzazione delle unità di codice}
La suddivisione intensiva in package garantisce la modularità per le varie funzionalità e migliora la fruibilità del codice.
Di seguito verranno elencati i package principali
\begin{itemize}
    \item \textbf{Client}: contiene le task da eseguire lato Client e la classe che verrà istanziata per usufruire del servizio
    \item \textbf{Commands}: contiene tutti i comandi che possono essere utilizzati dagli utenti, insieme alla factory per istanziarli
    \item \textbf{Communication}: contiene i protocolli di comunicazione utilizzati insieme ai tipi di messaggio definiti per la comunicazione
    \item \textbf{Config}: contiene le classi per configurare Client e Server
    \item \textbf{Executables}: contiene ServerMain e ClientMain che eseguiranno rispettivamente Server e Client del servizio Cross
    \item \textbf{JsonAccessedData}: contiene tutti i vari file Json utilizzati per mantenere informazioni persistenti
    \item \textbf{Server}: contiene le task da eseguire lato Server e la classe che verrà istanziata per creare il Server centrale del servizio Cross
    \item \textbf{Utils}: contiene varie classi di utilità che semplificano l'esecuzione del codice
\end{itemize}

\subsection{Comunicazione}
La comunicazione definita nel package \textbf{Communication} contiene i due protocolli utilizzati:

\begin{itemize}
    \item \textbf{TCP}: Protocollo maggiormente utilizzato per la comunicazione Client-Server mediante il quale il Client può inviare richieste al Server. La conessione viene instaurata all'avvio del Client e persiste fino alla chiusura dello stesso o di problemi che causano la chiusura del Server
    \item \textbf{UDP}: Protocollo utilizzato per notificare gli utenti della finalizzazione delle transazioni legate agli ordini da loro piazzati nell'orderbook
\end{itemize}

\subsection{Gestione di Orderbook e Registrazioni}
L'orderbook viene realizzato mediante un file Json diviso in due campi principali \textbf{askMap} e \textbf{bidMap} che contengono i relativi ordini
Questa scelta consente di persistere i dati sugli ordini anche dopo la chiusura del Server, oltre a garantire una relativa semplicita nel caricamento in memoria degli ordini tramite una struttura dati apposita.
\\La gestione delle registrazioni è simile mediante un \textbf{"Userbook"} con una chiave usermap per rendere più agevole la traduzione da Json a struttura dati, inoltre per garantire maggiore sicurezza le password sono state criptate grazie alla libreria \textbf{BCrypt}.

\subsection{Sincronizzazione}
Per garantire consistenza in un ambiente concorrente vengono utilizzati metodi \textbf{synchronized} per proteggere sezioni critiche ed inoltre le varie strutture dati presenti nella collezione \textbf{java.util.concurrent}.

\subsection{Design Pattern}
Il progetto utilizza principalmente la \textbf{Simple Factory} per generare i comandi da inviare al Server.
Questa generazione avviene sul Client sfruttando l'interfaccia \textbf{Values} la quale offre il metodo execute che il Server utilizzerà per eseguire correttamente i vari comandi disponibili. Inoltre questo approccio consente di mantenere invariato il formato di messaggi,\textbf{Message\{Operation,Values\}} che il Client invia al server e facilita l'aggiunta di comandi in quanto è sufficiente creare una nuova implementazione di Values.

\section{Schema Generale dei Thread Attivati}
Il progetto sfrutta il multithreading per gestire la comunicazione Client-Server in maniera efficiente, oltre all'elaborazione asincrona di attività interne
\subsection{Thread Lato Client}
Il client attiva ed usa 3 thread durante il normale funzionamento:
\begin{itemize}
  \item \textbf{SenderThread}: utilizzato per inviare i comandi al server mediante connessione \textbf{TCP}.
  \item \textbf{ReceiverThread}: utilizzato per ricevere le risposte del server mediante connessione \textbf{TCP}.
  \item \textbf{UDPReceiverThread}: utilizzato per ricevere le notifiche legate alle transazioni che riguardano gli ordini piazzati dall'utente mediante connessione \textbf{UDP}.
\end{itemize}
I primi due thread vengono istanziati nella classe ClientClass e persistono le informazioni fino alla chiusura del socket, la scelta di avere due thread separati per invio e ricezione consente di ricevere in maniera asincrona le risposte del server, aiutando quindi a gestire i casi in cui si riscontrano dei problemi sul server richiedendo però l'utilizzo di una variabile per sincronizzare i due thread impedendo così di inviare al massimo 1 messaggio alla volta aspettando così la relativa risposta.
\\ \textbf{UDPReceiverThread} viene istanziato subito dopo la ricezione del primissimo messaggio inviato dal server, che contiene le informazioni su porta e gruppo multicast al quale connettersi per ottenere informazioni sugli ordini.
È stato scelto di utilizzare multicast per semplificare l'implementazione del paradigma Publish-Subscribe per gli ordini; un'altro vantaggio di multicast consiste nel poter assegnare ad ogni ordine dell'orderbook un gruppo multicast, vantaggio che in questo progetto non è stato sfruttato appieno in quanto non richiesto esplicitamente.
\subsection{Thread Lato Server}
Il Server utilizza un \textbf{FixedThreadPool} per gestire i vari client connessi che vengono rappresentati da una \textbf{GenericTask}, inoltre attiva i seguenti Thread:
\begin{itemize}
  \item \textbf{UDPListner}: Thread che si occupa dell'invio delle notifiche secondo il modello Publish-Subscribe.
  \item \textbf{StopOrderChecker}: Thread che si occupa di controllare gli \textbf{StopOrder} piazzati dagli utenti ed eseguirli in caso lo stopprice lo consenta.
  \item \textbf{ClosingTask}: Thread che si occupa di svolgere la chiusura del server in sicurezza quando si riscontrano dei problemi sul server per i quali non si può garantire la fruizione del servizio di trading.
\end{itemize}

\section{File Java}
Il progetto sfrutta i java package per organizzare meglio i file Java contenenti le classi che verranno usate per fornire il servizio di trading; Di seguito verranno analizzati i vari package ed alcuni file tra i più importanti, motivando le scelte fatte.
\subsection{Communication}
Questo package contiene i protocolli di comunicazione utilizzati dal progetto, insieme ai tipi di messaggio che vengono scambiati tra Client e Server.
I protocolli, come menzionato precedentemente, sono \textbf{UDP} e \textbf{TCP} che vengono realizzati implementando l'interfaccia \textbf{Protocol} che richiede un metodo rispettivamente per invio e ricezione di messaggi ed uno per la chiusura del protocollo;
Inoltre \textbf{TCP} utilizza i metodi forniti da \textbf{Moshi} per realizzare uno scambio di messaggi in formato Json, sfruttando le varie implementazioni dell'interfaccia \textbf{Values}.

\begin{wrapfigure}{r}{0.5\textwidth} % "r" = destra, "l" = sinistra
  \centering
  \includegraphics[width=\linewidth]{Moshi-Classi.png} % Assicurati che il nome sia corretto
  %\caption{Aggiunta delle sottoclassi di Values a Moshi}
\end{wrapfigure}

Moshi si è rivelato più facilmente manutenibile rispetto a Gson in quanto non perde le informazioni della sottoclasse di \textbf{Values} incapsulata nel messggio inviato/ricevuto. Questo si è rivelato fondamentale in quanto ha permesso di mantenere la struttura dei messaggi richiesta dalla consegna. Questo si ottiene registrando tutti le Classi o sottoclassi che potrebbero essere passata nei Messaggi come si può notare nella fiigura affianco.
Inoltre per finire la configurazione di Moshi è bastato creare un \textbf{JsonAdapter$<$Message$>$} che, similmente a Gson, si occuperà di serializzare/deserializzare il messaggio in formato Json.

\subsection{Commands}

\subsection{Utils}

\subsection{JsonAccessedData}

\subsection{ClientClass}

\subsection{ServerClass}

\section{Primitive di Sincronizzazione}

\subsection{synchronized}

\subsection{volatile}
\subsection{ConcurrentSkipListMap}

\section{Utilizzare il Progetto}

\subsection{Requisiti di Sistema}

\subsection{Struttura del Progetto}

\subsection{Esecuzione del Progetto}


\end{document}